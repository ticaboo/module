<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<title>Module.js</title>
		<meta name="description" content="A library for creating modular JavaScript applications.">
    	<meta name="author" content="James Lockwood">
    	<meta name="keywords" content="modulejs, module.js, module, modular javascript, javascript module, modular javascript applications">
		<link rel="stylesheet" href="website/css/styles.css">
		<link rel="stylesheet" href="website/css/pygment_trac.css">
		<link rel="stylesheet" href="website/css/syntax.css">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
	</head>
	<body onload="prettyPrint()" id="top">
	<div class="wrapper">
		<header>
			<h1>Module.js</h1>
			<p>A lightweight library for creating modular JavaScript applications</p>

			<ul class="downloads">
				<li><a href="https://raw.github.com/jameslockwood/module/master/module.js"><strong>Download</strong>Module.js</a></li>
				<li><a href="https://raw.github.com/jameslockwood/module/master/module.min.js"><strong>Minified</strong>Module.js</a></li>
				<li><a href="https://github.com/jameslockwood/module"><strong>GitHub</strong>Project</a></li>
			</ul>

			<nav>

				<a class="toc-head" href="#top">Introduction</a>

				<a class="toc-head" href="#module">Module</a>

				<span class="subtitle"><a href="#module-properties">Properties</a></span>
				<ul>
					<li><a href="#module-scope">scope</a></li>
					<li><a href="#module-sscope">$scope</a></li>
					<li><a href="#module-events">events</a></li>
				</ul>

				<span class="subtitle"><a href="#module-messaging">Methods</a></span>
				<ul>
					<li class="method-head"><a href="#module-messaging">Messaging</a></li>
					<li><a href="#module-on">on</a></li>
					<li><a href="#module-off">off</a></li>
					<li><a href="#module-emit">emit</a></li>

					<li class="method-head"><a href="#module-dom">DOM Scope</a></li>
					<li><a href="#module-selector">$</a></li>
					<li><a href="#module-hide">hide</a></li>
					<li><a href="#module-show">show</a></li>
					<li><a href="#module-setscope">setScope</a></li>

					<li class="method-head"><a href="#module-utils">Utils</a></li>
					<li><a href="#module-bindevents">bindEvents</a></li>
					<li><a href="#module-createmap">createMap</a></li>
					<li><a href="#module-log">log</a></li>
					<li><a href="#module-throwexception">throwException</a></li>

					<li class="method-head"><a href="#module-lifecycle">Lifecycle Management</a></li>
					<li><a href="#module-start">start</a></li>
					<li><a href="#module-stop">stop</a></li>
				</ul>

				<span class="subtitle"><a href="#module-functions">Functions</a></span>
				<ul>
					<li><a href="#module-extend">Module.extend</a></li>
					<li><a href="#module-installeventsto">Module.installEventsTo</a></li>
				</ul>

				<a class="toc-head" href="#map">Map</a>
				<ul>
					<li><a href="#map-add">add</a></li>
					<li><a href="#map-each">each</a></li>
					<li><a href="#map-eachtry">eachTry</a></li>
					<li><a href="#map-length">length</a></li>
					<li><a href="#map-on">on</a></li>
					<li><a href="#map-off">off</a></li>
					<li><a href="#map-remove">remove</a></li>
				</ul>


				<a class="toc-head" href="#tutorials">Tutorials</a>
				<ul>
					<li><a href="#tutorials-creating">Creating a Module</a></li>
					<li><a href="#tutorials-scope">Using Module Scope</a></li>
					<li><a href="#tutorials-map">Using Maps</a></li>
					<li><a href="#tutorials-events">Hooking-up Events</a></li>
					<li><a href="#tutorials-app">Creating a Modular Application</a></li>
					<li><a href="#tutorials-lifecycle">Lifecycle Management</a></li>
				</ul>
			</nav>

		</header>

		<section>

			<p class="leader">
				Module.js enables you to build <strong>large-scale JavaScript applications</strong> that are composed of several <strong>decoupled</strong>, testable and reusable <strong>modules</strong>.
			</p>
			<p>
				It promotes apps to be built using a modular, event-driven architecture. Each module is aggressively self-concerned, having it's own DOM scope, it's own lifecycle management, and it's own messaging/events mechanism.</p>
			<p>The project his hosted on <a href="https://github.com/jameslockwood/module">GitHub</a>, and is available to use under the <a href="https://raw.github.com/jameslockwood/module/master/license">MIT Software License</a>.  You can report bugs on the <a href="https://github.com/jameslockwood/module/issues">GitHub issues page</a>.</p>

			<p>Module.js has no hard dependencies; however if you require DOM manipulation then <a href="http://www.jquery.com">jQuery</a> or <a href="http://www.zeptojs.com">Zepto</a> are needed.</p>

			<h2 id="intro">Introduction</h2>
			<p>When creating web apps in JavaScript with any degree of complexity, itâ€™s essential to have well-organized code; maintaining a spaghetti-coded project will only cause you pain and suffering as entropy provails. &nbsp;Module.js aims to help you take a modular approach when building JavaScript web apps, making your code more organized, scalable and maintainable.</p>
			<p>It provides a high-level architectural structure, leaving lower-level implementation choices (such as an individual module's usage of views, models, templating etc.) to be decided by the developer.  It's goal is to create disparate modules of which, once finished, can be dropped-in to any part of your application.  Just provide it with a DOM scope on instantiation and subscribe to any events of interest that it emits.</p>
			<p>You'll find the module.js API desribed in full below.  For more help, take a look at the <a href="#tutorials">tutorials</a>.  For further reading on large scale applicaiton development, try <a href="http://addyosmani.com/largescalejavascript/">Large Scale JavaScript</a> by Addy Osmani, and <a href="http://lanyrd.com/2011/jsconf/sfgdk/">The Fututure is Modules not Frameworks</a> by John Hann.</p>

			<h2 id="module">Module</h2>
			<p>To create a module, simply instantiate the Module constructor.  If the module is to be concerned with the DOM, then a DOM reference (in the form of a CSS selector or jQuery/Zepto object) should be passed in as the modules <code>scope</code>.  This will automatically set the module scope under-the-covers using <code><a href="#module-setscope">setScope()</a></code>.</p>
<pre><code class="prettyprint language-js">// creating a module
module = new Module();

// setting properties on instantiation
module = new Module({
  initialize : function(){},
  scope : '#app-wrapper'
});
</code></pre>

			<p>The <code>initialize()</code> method is automatically invoked when the module is created, if defined.  You can extend the module constructor too:</p>

<pre><code class="prettyprint language-js">// extending the Module constructor
App = Module.extend({
  initialize : function(){},
  start : function(){},
  stop : function(){}
});
// create our app, passing in it's scope
app = new App({scope : '#app-wrapper'});
app.start();
</code></pre>
			<p>You'll notice above that unimplemented <code><a href="#module-start">start</a></code> and <code><a href="#module-stop">stop</a></code> methods have been supplied.  These are the primary strategies to manage a <a href="#module-lifecycle">modules lifecycle</a>.</p>

			<h3 id="module-properties" class="sect">Properties</h3>
			<aside>
				<p>A module has three reserved properties that you need to have knowledge of. <code>scope</code> and <code>$scope</code> both relate to the modules <a href="#module-dom">DOM scope</a>. The <code>events</code> property is set manually to declare event handlers.</p>
			</aside>
			<article id="module-scope">
				<h3>scope <code><b>String</b></code></h3>
				<p>A CSS selector representing the modules DOM scope, for example <code>'#anElement'</code>.
				The value will be <code>null</code> if scope has not been set.</p>
			</article>

			<article id="module-sscope">
				<h3>$scope <code><b>Object</b></code></h3>

				<p>A jQuery/Zepto object referencing the modules DOM scope.  The value will be <code>null</code> if scope has not been set or jQuery/Zepto isn't being used.</p>
			</article>

			<article id="module-events">
				<h3>events <code><b>Object</b></code></h3>

				<p>An events hash.  It provides declarative callbacks to handle events that occur on objects within a module.  The context of the callback handlers ( <code>this</code> ) will always be the current module.</p>
				<p>A basic event declaration includes the object name of interest, the event it emits, and a handler function.
				</p>
<pre><code class="prettyprint">events:{
  'objectName eventName' : function(){ // handle event here }
}
</code></pre>
				<p>
				Suppose a module has a <code>model</code> object that will emit a <code>'change'</code> event.  We can listen for this event by:
				</p>
<pre><code class="prettyprint">new Module({
  initialize: function(){
    this.model = new Model();
    this.bindEvents();
  },
  events: {
    'model change' : function( data ){
      // handle the model's 'change' event
    }
  }
});
</code></pre>
				<p>We can assign multiple event handlers onto an object:</p>
<pre><code class="prettyprint">events:{
  'model' : {
    'change' : function( data ){},
    'reset' : function( arg ){},
    'destroy' : function( arg1, arg2 ){}
  }
}
</code></pre>
				<p>We can listen out for events across multiple objects by using a '<code>*</code>' wildcard:</p>
<pre><code class="prettyprint">events:{
  // handle 'change' event on the model
  'model change' : function( data ){ // do something },

  // handle 'change' event on any object
  '* change' : function( data ){ // captures same event },

  // handle multiple events on any object
  '*' : {
    'change' : function( data ){},
    'anotherEvent' : function(){}
  }
}
</code></pre>
				<p id="module-mapevents">When using <a href="#map">mappings</a>, matching event handlers are automatically bound - <a href="#module-bindevents"><code>bindEvents()</code></a> does not need to be called.
				Suppose a module has a <code>map</code> containing chat, email and notification sub-modules. Event handlers can be declared like so:</p>
<pre><code class="prettyprint">App = Module.extend({
  initialize: function(){
    this.widgets = this.createMap('widgets');
  },
  start: function(){
    this.widgets.add({
      'email' : new EmailModule({scope: this.$('#email')}),
      'chat' : new ChatModule({scope: this.$('#chat')}),
      'notification': new NotificationModule({scope: this.$('#notify')}),
    });
  },
  events: {
    // handles the chat widgets 'message' event
    'widgets.chat message': function( message ){
      this.widgets.get('notification').alert( message );
    },
    // handles any widgets 'message' event
    'widgets.* message': function( widget, widgetName, message ){
      this.widgets.get('notification').alert( message );
    }
  }
});
</code></pre>
				<p>Note how when using a '<code>*</code>' wildcard, the emitting <code>object</code> and <code>objectName</code> are injected into the beginning of the event handler function's arguments.</p>
			</article>
			<h3 id="module-messaging" class="sect">Communication Methods</h3>
			<aside>
				<p>A module is designed to be used in an event-driven architecture.  To promote loose coupling and seperation of concerns, each module is self-concerned and should assume no knowledge of <i>anything</i> beyond itself and it's contents, where possible.</p>
				<p>Following this paradigm, each module has it's own <a href="http://lostechies.com/derickbailey/2012/04/03/revisiting-the-backbone-event-aggregator-lessons-learned/">event aggregator</a> which can <code><a href="#module-emit">emit</a></code> events of interest, and also provides a mechanism for others to subcribe to any of these events using the <code><a href="#module-on">on</a></code> method.</p>
				<p><strong>Further Reading</strong> &nbsp; For more information on event-driven communication, take a look at the <a href="#tutorials-app">Creating a Modular Application tutorial</a> which covers how to 'wire-up' your various modules.  Additionally, Addy Osmani has written an explanation of cross-module communication using the <a href="http://addyosmani.com/largescalejavascript/#mediatorpattern">mediator pattern</a>.</p>
			</aside>
			<article id="module-on">
				<h3>on <code>( event<b>string</b>, handler<b>function</b>, [context] )</code></h3>
				<p>Provides a mechanism to subscribe to events emitted by a module.  The method binds a callback function to the module. The callback will be invoked whenever the event is fired.</p>
<pre><code class="prettyprint">module.on('error', function( error, message ){
  throw error;
})
</code></pre>
				<p>To supply a context value for <code>this</code> when the callback is invoked, pass the optional third argument.</code></p>
				<p>Related note:&nbsp; A modules <code><a href="#module-events">events</a></code> property can be used to declare event handlers on any of a module's properties which emit events.</p>

			</article>
			<article id="module-off">
				<h3>off <code>( [event<b>string</b>], [handler<b>function</b>], [context] )</code></h3>
				<p>Removes/unbinds a previously-bound callback function from the module. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed.</p>
<pre><code class="prettyprint">// Removes just the 'onError' event handler.
module.off('error', onError);

// Removes all 'error' event handlers.
module.off('error');

// Removes all event handlers on the module.
module.off();
</code></pre>
				<p>Remember to unbind events when you destroy your module - see the <a href="#tutorials-lifecycle">Module Lifecycle Management</a> tutorial.</p>
			</article>
			<article id="module-emit">
				<h3>emit <code>( event<b>string</b>, [*args<b>any</b>] )</code></h3>
				<p>Emits an event. Subsequent arguments provided to <code>emit</code> will be passed along to any event handlers.</p>
<pre><code class="prettyprint">// emit a 'newMessage' event
module.emit('newMessage');
// emit a 'newMessage' event with additional details
module.emit('newMessage', details);
</code></pre>
				<p>Events are described as any 'significant change in state'.  Modules should <code>emit</code> events when they have any useful information to present for consumption by others.</p>
			</article>

			<h3 id="module-dom" class="sect">DOM Scope Methods</h3>
			<aside>
				<p>Each module is self-concerned; it should only ever interact with it's own DOM scope.  The following methods provide access to a module's scoped DOM reference, ring-fencing it away from the rest of the DOM.</p>
				<p><strong>Note on DOM manipulation</strong> &nbsp; It's worth an important mention that each module shouldn't be <i>directly</i> resposible for manipulating it's own DOM reference. Each module is effectively acting like a pseudo-controller; managing it's own models, views, sub-modules, and event emission.</p>
				<p>Therefore - to keep things 'right and proper' - a module *should* delegate any DOM interactions to it's own view objects.</p>
			</aside>
			<article id="module-selector">
				<h3>$ <code>( selector<b>string</b> )</code></h3>
				<p>If jQuery or Zepto is included on the page, the <code>$</code> method performs DOM queries specifically scoped to the modules DOM reference.  This is the equivalent to <code>this.$scope.find()</code>.</p>
<pre><code class="prettyprint">// run a scoped query within our module
module.$('.foo');

// create a view within the module, passing in it's scope
myModule = new Module({
  initialize : function(){
    this.view = new Backbone.View({
      el: this.$('.foo')
    });
  },
  start : function(){
    this.view.render();
  }
});
</code></pre>
			</article>
			<article id="module-hide">
				<h3>hide ()</h3>
				<p>Hides the modules DOM element - equivalent to <code>this.$scope.hide()</code>. All other DOM manipulation should be delegated to views.</p>
			</article>
			<article id="module-show">
				<h3>show ()</h3>
				<p>Reveals the modules DOM element - equivalent to <code>this.$scope.show()</code>. All other DOM manipulation should be delegated to views.</p>
			</article>
			<article id="module-setscope">
				<h3>setScope <code>( scope<b>string or jquery/Zepto object</b> )</code></h3>
				<p>Sets the module's scope.  Accepts a CSS selector or a jQuery/Zepto object referencing a DOM element.  Automatically updates the <code><a href="#module-scope">scope</a></code> and <code><a href="#module-sscope">$scope</a></code> properties when invoked.</p>
			</article>

			<h3 id="module-utils" class="sect">Utility Methods</h3>
			<aside>
				<p>Various utility methods used for Map creation, event binding, logging and error handling.</p>
			</aside>
			<article id="module-bindevents">
				<h3>bindEvents ()</h3>
				<p>Binds event handlers set in <code><a href="#module-events">events</a></code> to any matching properties on the module.</p>
<pre><code class="prettyprint">Module.extend({
  initialize: function(){
    this.foo = new Model();
    this.bar = new View();
    // bind matching events to the above properties
    this.bindEvents();
  },
  events: {
    'foo testEvent': function(){ // implement },
    'bar someEvent': function(){ // implement }
  }
});
</code></pre>
				<p>If you are only using <code><a href="map">Maps</a></code> to store objects in your modules, matching events are automatically bound and <code>bindEvents</code> does not need to be called.</p>
			</article>
			<article id="module-createmap">
				<h3>createMap <code>( name<b>String</b> )</code></h3>
				<p>Returns a <code><a href="#map">Map</a></code> object.  The provided <code>name</code> is the map's identifier; it's used to automatically bind any matching event declarations in the <code><a href="#module-events">events</a></code> property when objects are added to the map.</p>
<pre><code class="prettyprint">Module.extend({
  initialize: function(){
    // create a map to store 'subModules'
    this.subModules = this.createMap('subModules');
    this.subModules.add({
      'email' : someObject,
      'chat' : anotherObject
    })
  },
  // our 'subModules' map events are automatically bound
  events: {
    'subModules.*': {
      'error': function(){},
      'update': function(){}
    },
    'subModules.email message': function( msg ){}
  }
});
</code></pre>
			</article>
			<article id="module-log">
				<h3>log <code>( [*<b>any</b>] )</code></h3>
				<p>Logs out supplied arguments to the console, if the console is available.</p>
			</article>
			<article id="module-throwexception">
				<h3>throwException <code>( error<b>Error</b>, [message<b>string</b>] )</code></h3>
				<p>Throws an error and emits an error event.</p>
<pre><code class="prettyprint">module.on('error', function(error, message){
  console.log( message );
});
// logs out 'Something went wrong';
module.throwException(new Error('Something went wrong'));
</code></pre>
			</article>

			<h3 id="module-lifecycle" class="sect">Lifecycle Methods</h3>
			<aside>
				<p>A <code>module</code>'s interface has unimplemented <code>start</code> and <code>stop</code> methods to allow others to tear-up and tear-down a module respectively.</p>
				<p>These methods should be the sole entry-points for these actions.  When <code>start()</code> is invoked on a module, the module should then take care of setting-up itself from here forth.  Similarly, <code>stop()</code> should completely tear-down the module, including any views, models and events (<code><a href="#module-off">off</a></code>).  See the <a href="#tutorials-lifecycle">Lifecycle Management tutorial</a> for further reading.</p>
			</aside>
			<article id="module-start">
				<h3>start ()</h3>
				<p>Implement this method as the sole entry-point to start the module.  When called, the <code>start()</code> method should fully take care of module installation - see the <a href="#tutorials-lifecycle">Lifecycle Management tutorial</a>.</p>
			</article>
			<article id="module-stop">
				<h3>stop ()</h3>
				<p>Implement this method as the sole entry-point to stop the module.  On tear-down, remember to destroy internal objects and unbind any events - see the <a href="#tutorials-lifecycle">Lifecycle Management tutorial</a>.</p>
			</article>

			<h3 id="module-functions" class="sect">'Static' Functions</h3>
			<aside>
				<p>Functions that are attached onto the <code>Module</code> constructor which are available to use whenever and wherever.</p>
			</aside>
			<article id="module-extend">
				<h3>Module.extend <code>( properties<b>object</b>, [classProperties<b>object</b>] )</code></h3>
				<p>Use to create your own <code>Module</code> 'class' by extending <code>Module</code>.  Provide instance properties, as well as optional classProperties to be attached directly to the modules's constructor function.</p>
<pre><code class="prettyprint">var MyModule = Module.extend({
  initialize: function(){ // implement },
  start: function(){ // implement },
  stop:  function(){ // implement },
  events {
    // implement
  }
});
</code></pre>
			</article>
			<article id="module-installeventsto">
				<h3>Module.installEventsTo <code>( targetObject<b>object</b> )</code></h3>
				<p>Mixes in an event aggregator onto the target object, providing the object with the same event method signature as described in <a href="#module-messaging">Module Messaging</a>.</p>
<pre><code class="prettyprint">var testObject = {};
Module.installEventsTo( testObject );
testObject.emit('iCanEmitEvents');
</code></pre>
			</article>

			<h2 id="map">Map</h2>
			<aside>
				<p>A map object acts like a colleciton.  It allows us to <code>add</code>, <code>get</code> and <code>remove</code> objects in a consistent manner.  It also provides an interface to iterate over all objects within the map (<code>each</code>) and to listen for events on objects within the map (<code>on</code>).  See the <a href="#tutorials-maps">Using Maps tutorial</a>.</p>
				<p>Maps are created using a module's <code><a href="#module-createmap">createMap</a></code> method.</p>
			</aside>
			<article id="map-add">
				<h3>add <code>( name<b>String</b>, object<b>Object</b> )</code></h3>
				<p>Adds an object to the current map.</p>
<pre><code class="prettyprint">// add a single object
models.add('myModel', new Model());

// add multiple objects
models.add({
  'myModel': new Model(),
  'yourModel': new Model(),
  'ourModel': new Model()
});
</code></pre>
			<p>Multiple objects can be added with the same name, if desired.  An array of the objects is then returned upon a <code>get</code> call if more than one object exists in the mapped value.</p>
<pre><code class="prettyprint">// add a single object mapped to 'test'
models.add('test', new Model());

models.get('test'); // returns model

// add more objects to the same 'test' mapped value
models.add('test', new Model());
models.add('test', new Model());

models.get('test'); // returns [ model, model, model ]
</code></pre>
			</article>
			<article id="map-each">
				<h3>each <code>( mixed )</code></h3>
				<p>Iterates over each object in the map, invoking a method or applying a callback function depending on the arguments provided.</p>
				<p>Method invocation on each object via passing method name and arguments:</p>
<pre><code class="prettyprint">// executes 'foo()' on each object in the map
models.each('foo');

// executes 'foo()' on each, passing true into the method
models.each('foo', true )
</code></pre>
				<p>Iterating over each object by passing in a function callback:</p>
<pre><code class="prettyprint">// applies callback on each object in the map
models.each( function( model, name ){
  model.foo();
});
</code></pre>
			</article>
			<article id="map-eachtry">
				<h3>eachTry <code>( methodName<b>String</b>, [*<b>any</b>] )</code></h3>
				<p>Similar to each, however if the stated method does not exist then no error is thrown.  This is useful when we want to try invoke a mathod on all of our objects in a map knowing that the method may not exist on some objects.</p>
			</article>
			<article id="map-length">
				<h3>length ()</h3>
				<p>Returns the number of objects currently in the map.</p>
			</article>
			<article id="map-on">
				<h3>on <code>( event<b>string</b>, handler<b>function</b>, [context] )</code></h3>
				<p>Handle events on all objects within the map.  See <code><a href="#module-on">on()</a></code> and <a href="#module-mapevents">declaring map events</a>.  The mapped <code>object</code> emitting the event and it's <code>name</code> are injected into the handler function.</p>
<pre><code class="prettyprint">// add objects to the models map
models.add({
  'myModel': new Model(),
  'yourModel': new Model(),
  'ourModel': new Model()
});

// declare an event handler
models.on( 'change', function( model, modelName, data ){
  this.log('The model ' + modelName + ' has changed.');
});

// logs out 'The model myModel has changed'
models.get('myModel').emit('change');
</code></pre>
			</article>
			<article id="map-off">
				<h3>off <code>( [event<b>string</b>], [handler<b>function</b>], [context] )</code></h3>
				<p>Remove event handlers on all objects within the map.  See <code><a href="#module-off">off()</a></code></p>
			</article>
			<article id="map-remove">
				<h3>remove <code>( [objectName<b>String</b>] )</code></h3>
				<p>Removes one or all objects from a map.</p>
<pre><code class="prettyprint">models.add({
  'myModel': new Model(),
  'yourModel': new Model(),
  'ourModel': new Model()
});
models.length(); // 3

// remove 'myModel' object
models.remove('myModel');
models.length(); // 2

// remove all objects in the map
models.remove();
models.length(); // 0
</code></pre>
			</article>

			<h2 id="tutorials">Tutorials</h2>
			<h3 id="tutorials-creating">Creating a Module</h3>
			<p>Coming soon.</p>
			<h3 id="tutorials-scope">Using Module Scope</h3>
			<p>Coming soon.</p>
			<h3 id="tutorials-map">Using Maps</h3>
			<p>Coming soon.</p>
			<h3 id="tutorials-events">Hooking-Up Events</h3>
			<p>Coming soon.</p>
			<h3 id="tutorials-app">Creating a Modular Application</h3>
			<p>Coming soon.</p>
			<h3 id="tutorials-lifecycle">Module Lifecycle Management - Cleaning Up After Yourself</h3>
			<p>Coming soon.</p>
		</section>

		<footer>
			<p>Project maintained by <a href="https://github.com/jameslockwood">jameslockwood</a></p>
			<p><small>Hosted on GitHub Pages. &nbsp;Adapted <a href="https://github.com/orderedlist">orderedlist</a> theme. &nbsp;Syntax highlighting using <a href="https://code.google.com/p/google-code-prettify/">Google Prettify</a></small></p>
		</footer>

	</div>

	<script src="website/js/scale.fix.js"></script>
	<script src="website/js/syntax.js"></script>

	</body>
</html>