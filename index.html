<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<title>Module.js</title>

		<link rel="stylesheet" href="website/css/styles.css">
		<link rel="stylesheet" href="website/css/pygment_trac.css">
		<link rel="stylesheet" href="website/css/syntax.css">

		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
	</head>
	<body onload="prettyPrint()" id="top">
	<div class="wrapper">
		<header>
			<h1>Module.js</h1>
			<p>A lightweight library for creating modular JavaScript applications</p>

			<ul class="downloads">
				<li><a href="https://raw.github.com/jameslockwood/module/master/module.js"><strong>Download</strong>Module.js</a></li>
				<li><a href="https://raw.github.com/jameslockwood/module/master/module.min.js"><strong>Minified</strong>Module.js</a></li>
				<li><a href="https://github.com/jameslockwood/module"><strong>GitHub</strong>Project</a></li>
			</ul>

			<nav>

				<a class="toc-head" href="#top">Introduction</a>

				<a class="toc-head" href="#module">Module</a>

				<span class="subtitle"><a href="#module-properties">Properties</a></span>
				<ul>
					<li><a href="#module-scope">scope</a></li>
					<li><a href="#module-sscope">$scope</a></li>
					<li><a href="#module-events">events</a></li>
				</ul>

				<span class="subtitle"><a href="#module-messaging">Methods</a></span>
				<ul>
					<li class="method-head"><a href="#module-messaging">Messaging</a></li>
					<li><a href="#module-on">on</a></li>
					<li><a href="#module-off">off</a></li>
					<li><a href="#module-emit">emit</a></li>

					<li class="method-head"><a href="#module-dom">DOM Scope</a></li>
					<li><a href="#module-selector">$</a></li>
					<li><a href="#module-hide">hide</a></li>
					<li><a href="#module-show">show</a></li>
					<li><a href="#module-setscope">setScope</a></li>

					<li class="method-head"><a href="#module-utils">Utils</a></li>
					<li><a href="#module-bindevents">bindEvents</a></li>
					<li><a href="#module-createmap">createMap</a></li>
					<li><a href="#module-log">log</a></li>
					<li><a href="#module-throwexception">throwException</a></li>

					<li class="method-head"><a href="#module-lifecycle">Lifecycle Management</a></li>
					<li><a href="#module-start">start</a></li>
					<li><a href="#module-stop">stop</a></li>
				</ul>

				<span class="subtitle"><a href="#module-functions">Functions</a></span>
				<ul>
					<li><a href="#module-extend">Module.extend</a></li>
					<li><a href="#module-installeventsto">Module.installEventsTo</a></li>
				</ul>

				<a class="toc-head" href="#map">Map</a>
				<ul>
					<li><a href="#map-add">add</a></li>
					<li><a href="#map-each">each</a></li>
					<li><a href="#map-eachtry">eachTry</a></li>
					<li><a href="#map-length">length</a></li>
					<li><a href="#map-on">on</a></li>
					<li><a href="#map-off">off</a></li>
					<li><a href="#map-remove">remove</a></li>
				</ul>


				<a class="toc-head" href="#tutorials">Tutorials</a>
				<ul>
					<li><a href="#tutorials-creating">Creating a Module</a></li>
					<li><a href="#tutorials-scope">Using Module Scope</a></li>
					<li><a href="#tutorials-map">Using Maps</a></li>
					<li><a href="#tutorials-events">Hooking-up Events</a></li>
					<li><a href="#tutorials-app">Creating a Modular Application</a></li>
					<li><a href="#tutorials-lifecycle">Lifecycle Management</a></li>
				</ul>
			</nav>

		</header>

		<section>

			<p class="leader">Talk about instances.  No parent / child relationship.  Drop in a module anywhere (providing it a DOM scope if it has any interactions with the DOM),  subscribe to itâ€™s events, and go from there.</p>

			<h2 id="intro">Introduction</h2>
			<p>Stuff here...  Dependencies,  what it works with.  Link to tutorials when they're done.</p>
			<p>Modular Javascript Architectures - link to other resources.</p>

			<h2 id="module">Module</h2>
			<p>To create a module, simply instantiate the Module constructor.  If the module is to be concerned with the DOM, then a DOM reference (in the form of a CSS selector or jQuery/Zepto object) should be passed in as the modules <code>scope</code>.</p>
<pre><code class="prettyprint language-js">// creating a module
module = new Module();

// setting properties on instantiation
module = new Module({
  initialize : function(){},
  scope : '#app-wrapper'
});
</code></pre>

			<p>The <code>initialize()</code> method is automatically invoked when the module is created.  You can extend the module constructor too:</p>

<pre><code class="prettyprint language-js">// extending the Module constructor
App = Module.extend({
  initialize : funciton(){},
  start : function(){},
  stop : function(){}
});
// create our app, passing in it's scope
app = new App({scope : '#app-wrapper'});
app.start();
</code></pre>
			<p>You'll notice above that unimplemented <code>start</code> and <code>stop</code> methods have been supplied.  These are the primary strategies to manage a modules lifecycle.</p>

			<h3 id="module-properties" class="sect">Properties</h3>
			<aside>
				<p>A module has three reserved properties that you need to have knowledge of. <code>scope</code> and <code>$scope</code> both relate to the modules <a href="#module-dom">DOM scope</a>. The <code>events</code> property is set manually to declare event handlers.</p>
			</aside>
			<article id="module-scope">
				<h3>scope <code><b>String</b></code></h3>
				<p>A CSS selector representing the modules DOM scope, for example <code>'#anElement'</code>.
				Value will be <code>null</code> if scope has not been set.</p>
			</article>

			<article id="module-sscope">
				<h3>$scope <code><b>Object</b></code></h3>

				<p>A jQuery/Zepto object referencing the modules DOM scope.  Value will be <code>null</code> if scope has not been set or jQuery/Zepto isn't being used.</p>
			</article>

			<article id="module-events">
				<h3>events <code><b>Object</b></code></h3>

				<p>An events hash.  It provides declarative callbacks to handle events that occur on objects within a module.  The context of the callback handlers ( <code>this</code> ) will always be the current module.</p>
				<p>A basic event declaration includes the object name of interest, the event it emits, and a handler function.
				</p>
<pre><code class="prettyprint">events:{
  'objectName eventName' : function(){ // handle event here }
}
</code></pre>
				<p>
				Suppose a module has a <code>model</code> object that will emit a <code>'change'</code> event.  We can listen for this event by:
				</p>
<pre><code class="prettyprint">new Module({
  initialize: function(){
    this.model = new Model();
    this.bindEvents();
  },
  events: {
    'model change' : function( data ){
      // handle the model's 'change' event
    }
  }
});
</code></pre>
				<p>We can assign multiple event handlers on an object:</p>
<pre><code class="prettyprint">events:{
  'model' : {
    'change' : function( data ){},
    'reset' : function( arg ){},
    'destroy' : function( arg1, arg2 ){}
  }
}
</code></pre>
				<p>We can listen out for events across multiple objects by using a wildcard:</p>
<pre><code class="prettyprint">events:{
  // handle change event on the model
  'model change' : function( data ){ // do something },

  // handle change event on any object
  '* change' : function( data ){ // captures same event },

  // handle multiple events on any object
  '*' : {
    'change' : function( data ){},
    'anotherEvent' : function(){}
  }
}
</code></pre>
				<p>When using <a href="#map">mappings</a>, matching event handlers are automatically bound - <a href="#module-bindevents"><code>bindEvents()</code></a> does not need to be called.
				Suppose a module has a <code>map</code> containing chat, email and notification sub-modules. Event handlers can be declared like so:</p>
<pre><code class="prettyprint">App = Module.extend({
  initialize: function(){
    this.widgets = this.createMap('widgets');
  },
  start: function(){
    this.widgets.add({
      'email' : new EmailModule({scope: this.$('#email')}),
      'chat' : new ChatModule({scope: this.$('#chat')}),
      'notification': new NotificationModule({scope: this.$('#notify')}),
    });
  },
  events: {
    // handles the chat widgets 'message' event
    'widgets.chat message': function( message ){
      this.widgets.get('notification').alert( message );
    },

    // handles any widgets 'message' event
    // the maps object and name are automatically
    // injected into the handler function
    'widgets.* message': function( widget, widgetName, message ){
      this.widgets.get('notification').alert( message );
    }
  }
});
</code></pre>
			</article>
			<h3 id="module-messaging" class="sect">Communication Methods</h3>
			<aside>
				<p>A module is designed to be used in an event-driven architecture.  To promote loose coupling and seperation of concerns, each module is self-concerned and should assume no knowledge of <i>anything</i> beyond itself and it's contents, where possible.</p>
				<p>Following this paradigm, each module has it's own <a href="http://lostechies.com/derickbailey/2012/04/03/revisiting-the-backbone-event-aggregator-lessons-learned/">event aggregator</a> which can <code><a href="#module-emit">emit</a></code> events of interest, and also provides a mechanism for others to subcribe to any of these events using the <code><a href="#module-on">on</a></code> method.</p>
				<p><strong>Further Reading</strong> &nbsp; For more information on event-driven communication, take a look at the <a href="#tutorials-app">Creating a Modular Application</a> tutorial which covers how to 'wire-up' your various modules.  Additionally, Addy Osmani has written an explanation of cross-module communication using the <a href="http://addyosmani.com/largescalejavascript/#mediatorpattern">mediator pattern</a>.</p>
			</aside>
			<article id="module-on">
				<h3>on <code>( event<b>string</b>, handler<b>function</b>, [context] )</code></h3>
				<p>Provides a mechanism to subscribe to events emitted by a module.  The method binds a callback function to the module. The callback will be invoked whenever the event is fired.</p>
<pre><code class="prettyprint">module.on('error', function( error, message ){
  throw error;
})
</code></pre>
				<p>To supply a context value for <code>this</code> when the callback is invoked, pass the optional third argument.</code></p>
				<p>Related note:&nbsp; A modules <code><a href="#module-events">events</a></code> property can be used to declare event handlers on any of a module's properties which emit events.</p>

			</article>
			<article id="module-off">
				<h3>off <code>( [event<b>string</b>], [handler<b>function</b>], [context] )</code></h3>
				<p>Removes a previously-bound callback function from the module. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed.</p>
<pre><code class="prettyprint">// Removes just the 'onError' callback.
module.off('error', onError);

// Removes all 'error' callbacks.
module.off('error');

// Removes all callbacks on the module.
module.off();
</code></pre>
				<p>Remember to unbind events when you destoy your module - see the <a href="#tutorials-lifecycle">Module Lifecycle Management</a> tutorial.</p>
			</article>
			<article id="module-emit">
				<h3>emit <code>( event<b>string</b>, [*args<b>any</b>] )</code></h3>
				<p>Emits an event. Subsequent arguments provided in <code>emit</code> will be passed along to any event handlers.</p>
<pre><code class="prettyprint">module.emit('newMessage');
module.emit('newMessage', details);
</code></pre>
			</article>

			<h3 id="module-dom" class="sect">DOM Scope Methods</h3>
			<aside>
				<p>Each module is self-concerned; it should only ever interact with it's own DOM scope.  The following methods provide access to a module's scoped DOM reference, ring-fencing it away from the rest of the DOM.</p>
				<p><strong>Note</strong> &nbsp; It's worth an important mention that each module shouldn't be <i>directly</i> resposible for manipulating it's own DOM reference. Each module in-effect is acting like a controller, managing it's own models, views and event emission.</p>
				<p>Therefore - to keep things right and proper - a module *should* delegate any DOM interactions to it's own view objects.</p>
			</aside>
			<article id="module-selector">
				<h3>$ <code>( selector<b>string</b> )</code></h3>
				<p>If jQuery or Zepto is included on the page, each module has a $ function that runs queries scoped within the modules DOM scope.</p>
<pre><code class="prettyprint">// run a scoped query within our module
module.$('.foo');

// create a Backbone view, passing in the module's scope
myModule = new Module({
  initialize : function(){
    this.view = new Backbone.View({
      el: this.$('.foo')
    });
  },
  start : function(){
    this.view.render();
  }
});
</code></pre>
			</article>
			<article id="module-hide">
				<h3>hide ()</h3>
				<p>Hides the modules element - equivalent to <code>this.$scope.hide()</code>. All other DOM manipulation should be delegated to views.</p>
			</article>
			<article id="module-show">
				<h3>show ()</h3>
				<p>Show the modules element - equivalent to <code>this.$scope.show()</code>. All other DOM manipulation should be delegated to views.</p>
			</article>
			<article id="module-setscope">
				<h3>setScope <code>( scope<b>string or jquery/Zepto object</b> )</code></h3>
				<p>Sets the module's scope.  Accepts a CSS selector or a jQuery/Zepto object referencing a DOM element.</p>
			</article>

			<h3 id="module-utils" class="sect">Utility Methods</h3>
			<aside>
				<p>Various utility methods used for Map creation, event binding, logging and error handling.</p>
			</aside>
			<article id="module-bindevents">
				<h3>bindEvents ()</h3>
				<p>Binds event handlers set in <code><a href="#module-events">events</a></code> to any matching properties on the module.</p>
			</article>
			<article id="module-createmap">
				<h3>createMap <code>( name<b>String</b> )</code></h3>
				<p>Returns a <code>Map</code> object - see <code><a href="#map">Map</a></code> documentation.</p>
			</article>
			<article id="module-log">
				<h3>log <code>( [*<b>any</b>] )</code></h3>
				<p>Logs out supplied arguments to the console, if the console is available.</p>
			</article>
			<article id="module-throwexception">
				<h3>throwException <code>( error<b>Error</b>, [message<b>string</b>] )</code></h3>
				<p>Throws an error and emits an error event.</p>
<pre><code class="prettyprint">module.on('error', function(error, message){
  console.log( message );
});
// logs out 'Something went wrong';
module.throwException(new Error('Something went wrong'));
</code></pre>
			</article>

			<h3 id="module-lifecycle" class="sect">Lifecycle Methods</h3>
			<aside>
				<p>Todo - link to tutorials.</p>
			</aside>
			<article id="module-start">
				<h3>start ()</h3>
				<p>TODO.</p>
			</article>
			<article id="module-stop">
				<h3>stop <code>( name<b>String</b> )</code></h3>
				<p>TODO.</p>
			</article>

			<h3 id="module-functions" class="sect">'Static' Functions</h3>
			<aside>
				<p>Functions that are attached onto the <code>Module</code> constructor which are available to use whenever and wherever.</p>
			</aside>
			<article id="module-extend">
				<h3>Module.extend <code>( properties<b>object</b>, [classProperties<b>object</b>] )</code></h3>
				<p>Use to create your own <code>Module</code> 'class' by extending <code>Module</code>.  Provide instance properties, as well as optional classProperties to be attached directly to the modules's constructor function.</p>
<pre><code class="prettyprint">var MyModule = Module.extend({
  initialize: function(){ // implement },
  start: function(){ // implement },
  stop:  function(){ // implement },
  events {
    // implement
  }
});
</code></pre>
			</article>
			<article id="module-installeventsto">
				<h3>Module.installEventsTo <code>( targetObject<b>object</b> )</code></h3>
				<p>Mixes in an event aggregator onto the target object, providing the object with the same event method signature as described in <a href="#module-messaging">Module Messaging</a>.</p>
<pre><code class="prettyprint">var testObject = {};
Module.installEventsTo( testObject );
testObject.emit('iCanEmitEvents');
</code></pre>
			</article>

			<h2 id="map">Map</h2>
			<aside>
				<p>A map object acts like a colleciton.  It allows us to add, get and remove in a consistent manner.  It also provides an interface to iterate over all objects within the map and to listen for events on objects within the map.</p>
				<p>Maps are created using a modules <code><a href="#module-createmap">createMap</a></code> method.</p>
			</aside>
			<article id="map-add">
				<h3>add <code>( name<b>String</b>, object<b>Object</b> )</code></h3>
				<p>Adds an object to the current map.</p>
<pre><code class="prettyprint">// add a single object
models.add('myModel', new Model());

// add multiple objects
models.add({
  'myModel': new Model(),
  'yourModel': new Model(),
  'ourModel': new Model()
});
</code></pre>
			<p>Multiple objects can be added with the same name if, desired.  An array of the objects is then returned upon a <code>get</code> call if more than one object exists in the mapped value.</p>
<pre><code class="prettyprint">// add a single 'test' object
models.add('test', new Model());

models.get('test'); // returns model

// add more 'test' objects to the same mapping
models.add('test', new Model());
models.add('test', new Model());

models.get('test'); // returns [ model, model, model ]
</code></pre>
			</article>
			<article id="map-each">
				<h3>each <code>( mixed )</code></h3>
				<p>Iterates over each object in the map, invoking a method or applying a callback function depending on the arguments provided.</p>
				<p>Method invocation on each object via passing method name and arguments:</p>
<pre><code class="prettyprint">// executes 'foo()' on each object in the map
models.each('foo');

// executes 'foo()' on each, passing true into the method
models.each('foo', true )
</code></pre>
				<p>Iterating over each object by passing in a function callback:</p>
<pre><code class="prettyprint">// applies callback on each object in the map
models.each( function( model, name ){
  model.foo();
});
</code></pre>
			</article>
			<article id="map-eachtry">
				<h3>eachTry <code>( methodName<b>String</b>, [*<b>any</b>] )</code></h3>
				<p>Similar to each, however if the stated method does not exist then no error is thrown.  This is useful when we want to try invoke a mathod on all of our objects in a map knowing that the method may not exist on some objects.</p>
			</article>
			<article id="map-length">
				<h3>length ()</h3>
				<p>Returns the number of objects currently in the map.</p>
			</article>
			<article id="map-on">
				<h3>on <code>( event<b>string</b>, handler<b>function</b>, [context] )</code></h3>
				<p>Handle events on all objects within the map.  See <code><a href="#module-on">on()</a></code>.  The <code>object</code> emitting the error and it's <code>name</code> are injected into the handler function.</p>
<pre><code class="prettyprint">// add objects to the models map
models.add({
  'myModel': new Model(),
  'yourModel': new Model(),
  'ourModel': new Model()
});

// declare an event handler
models.on( 'change', function( model, modelName, data ){
  this.log('The model ' + modelName + ' has changed.');
});

// logs out 'The model myModel has changed'
models.get('myModel').emit('change');
</code></pre>
			</article>
			<article id="map-off">
				<h3>off <code>( [event<b>string</b>], [handler<b>function</b>], [context] )</code></h3>
				<p>Remove event handlers on all objects within the map.  See <code><a href="#module-off">off()</a></code></p>
			</article>
			<article id="map-remove">
				<h3>remove <code>( [objectName<b>String</b>] )</code></h3>
				<p>Removes one or all objects from a map.</p>
<pre><code class="prettyprint">models.add({
  'myModel': new Model(),
  'yourModel': new Model(),
  'ourModel': new Model()
});
models.length(); // 3

// remove 'myModel' object
models.remove('myModel');
models.length(); // 2

// remove all objects in the map
models.remove();
models.length(); // 0
</code></pre>
			</article>
		</section>

		<footer>
			<p>Project maintained by <a href="https://github.com/jameslockwood">jameslockwood</a></p>
			<p><small>Hosted on GitHub Pages. &nbsp;Adapted <a href="https://github.com/orderedlist">orderedlist</a> theme. &nbsp;Syntax highlighting using <a href="https://code.google.com/p/google-code-prettify/">Google Prettify</a></small></p>
		</footer>

	</div>

	<script src="website/js/scale.fix.js"></script>
	<script src="website/js/syntax.js"></script>

	</body>
</html>